<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>JS实现继承的几种方式</title>
</head>
<body>
<h3>JS实现继承的几种方式</h3>
<script src="../../node_modules/jquery/dist/jquery.min.js"></script>
<script type="text/javascript">
    $(function () {
        //
        function Animal(name){
            //属性
            this.name = name || "Animal";
            //实例方法
            this.sleep = function () {
                console.log(this.name + " 正在睡觉....");
            }
        }
        //原型方法
        Animal.prototype.eat = function (food) {
            console.log(this.name + " 正在吃 "+ food);
        };

        /**
         * http://www.cnblogs.com/humin/p/4556820.html
         * 1原型链继承
         * 核心：将父类的实例作为子类的原型
         *
         * 特点：
         * 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
         * 父类新增原型方法/原型属性，子类都能访问到
         * 简单，易于实现
         *
         * 缺点：
         * 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
         * 无法实现多继承
         * 来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）
         * 创建子类实例时，无法向父类构造函数传参
         *
         * 推荐指数：★★（3、4两大致命缺陷）
         */

//        function Cat(){
//            this.wew = function () {
//                console.log("wewo...");
//            }
//        };
//        Cat.prototype = new Animal("cat");
//
//
//        //　Test Code
//        var cat = new Cat();
//        console.log(cat.name);
//        console.log(cat.eat('fish'));
//        console.log(cat.sleep());
//        console.log(cat instanceof Animal);
//        console.log(cat instanceof Cat);
//        cat.wew();

        /**
         * 2、构造继承
         * 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
         */
        function Cat(name){
            Animal.call(this);
            this.name = name || 'Tom'
        }
        test code



    })
</script>
</body>
</html>